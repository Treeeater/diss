\chapter[The Explication Process] {The Explication Process\footnote{The contents of this chapter is based on the paper: Explicating SDKs: Uncovering Assumptions Underlying Secure Authentication and Authorization~\cite{explicatingSDKs}.}}
\label{sec:explication}

Having a secure implementation of the authentication system lays a solid foundation for a successful application.  Even when the application's native authentication implementation is secure, integrating third-party SSO services may significantly complicates the situation.  Recent years, many researchers have done work to find vulnerabilities in such integrations, however, no previous study has rigorously examined the security properties these SDKs provide to real-world applications.  Typically, SDK providers simply release SDK code, publish related documentation and examples, and leave the rest to the app developers.  An important question remains: if developers use the SDKs in reasonable ways, will the resulting applications be secure?  We show in this chapter that the answer today is \emph{No}.  The majority of apps built using the SDKs we studied have serious security flaws.  In addition to direct vulnerabilities in the SDK, many flaws exists because achieving desired security properties by using an SDK depends on many implicit assumptions that are not readily apparent to app developers. These assumptions are not documented anywhere in the SDK or its documentation. In several cases, even the SDK providers are unaware of these assumptions.

This motivates us to develop a more systematic approach --- \emph{the explication process}, through which we hope to offer more confidence to the service provider and the application developer that no missing assumptions or vulnerabilities are left behind.  The goal of this work is to systematically identify the assumptions needed to securely integrate the SDK.  We emphasize that it is not meaningful to verify an SDK by itself.  Instead, our goal is to explicate the assumptions upon which secure use of the SDK depends.  We do this by devising precise definitions of desired security properties, constructing an explicit model of the SDK and the complex services with which it interacts, and systematically exploring the space of applications that can be built using the SDK.  Our approach involves a combination of manual effort and automated formal verification.  Any counterexample found by the verification tool indicates either (1) that our system models are not accurate, in which case we revisit the real systems to correct the model; or (2) that our models are correct, but additional assumptions need to be captured in the model and followed by application developers.  The explication process is an iteration of the above steps so that we document, examine and refine our understanding of the underlying systems for an SDK.  At the end, we get a set of formally captured assumptions and a semantic model that allow us to make meaningful assurances about the SDK: an application constructed using the SDK following the documented assumptions satisfies desired security properties.

We argue that the explication process should be part of the engineering effort of developing an SDK.  Newly discovered security-critical assumptions through this process can either be dismissed by modifying the SDK (the preferable solution), or be documented precisely.

For the rest of this chapter, we first discuss prior works in more details in Chapter~\ref{sec:explicating_prior_works}.  We then describe an illustrative missing implicit assumption example in Chapter~\ref{sec:explicating_illustrative_example}, how the iterative explication process works in Chapter~\ref{sec:explicating_explication_process}, how various parts of the system are modeled in Chapter~\ref{sec:explicating_semantic_modeling}, and finally the discoveries we make using this approach on Facebook and Microsoft's SSO services in Chapter~\ref{sec:explicating_discoveries}.

\section{Prior Works}
\label{sec:explicating_prior_works}

The idea of formally verifying properties of software systems goes back to Alan Turing, although it only recently became possible to automatically verify interesting properties of complex, large scale systems.  The explication process makes use of considerable advances in model checking that have enabled model checkers to work effectively on models as complex as the ones we use here.  This approach is most closely related to other work on inferring and verifying properties of interfaces such as APIs and SDKs, which are briefly reviewed next.

\subsection{API and SDK Misuses}

It is no longer a mystery that APIs and SDKs can be misunderstood and the results often include security problems.  On various UNIX systems, \emph{setuid} and other related system calls are non-trivial for programmers to understand.  Chen et al. ``demystified'' (that is, explicated) these functions by comparing them on different UNIX versions and formally modeling these system calls as transitions in finite state automata~\cite{Chen:2002:SD:647253.720278}.  Wang et al.~\cite{Wang:2011:SFO:2006077.2006782,Wang:2012:SMY:2310656.2310691} showed logic bugs in how websites integrate third-party cashier and SSO services.  Many of the bugs found appear to result from website developers' confusions about API usage. Georgiev et al.~\cite{Georgiev:2012:MDC:2382196.2382204} showed that SSL certificate validations in many non-browser applications are broken, which make the applications vulnerable to network man-in-the-middle attacks.  Our work started from a different perspective --- our primary goal is not to show that SDKs can be misused, but to argue that these misuses are so reasonable that it is SDK providers' lapse not to explicate the SDKs to make their assumptions clear.  We expect that our approach could be adapted to other contexts such as third-party payment and SSL certificate validation. 

\subsection{Program and Interface Verification}

Various techniques have been proposed to help automatically verify certain program properties regarding library interfaces.  Spinellis and Louridas~\cite{Spinellis:2007:FSV:1244490.1244957} built a static analysis framework for verifying Java API calls.  Library developers are required to write imperative checking code for each API to assist the verification process.  Henzinger et al.~\cite{deAlfaro:2001:IA:503209.503226,Beyer:2005:WSI:1060745.1060770} worked on a set of languages and tools to help model the interfaces and find assumptions that need to be met for two APIs to be \emph{compatible}.  The compatibility check is performed by computing compatible states, which amounts to solving a game between the product automaton (which tries to enter illegal states) and its environment (which tries to prevent this).  JIST~\cite{Alur:2005:SIS:1040305.1040314} infers necessary call sequences given a class and an exception property for Java, so that the exception is never raised.  Our proposed work has similar goals but is more focused on the study of details of complex real-world integrated systems and developing a systematic approach to analyze them.  We do not assume source code access from the system.  For example, our work involves probing and summarizing semantics for various parts of the SSO system including the device runtime, identity provider back end server, and application back end server.

Several works have automatically inferred program invariants or specifications.  Daikon~\cite{ErnstGKN99,Ernst2000:PhD,ErnstCGN2001:TSE} automatically learns program invariants of variables (strings, certain data structures, etc.) by instrumenting the program, running test cases, collecting and analyzing program traces.  Felmetsger et al.~\cite{Felmetsger:2010:TAD:1929820.1929834} applies Daikon to web applications to detect logic vulnerabilities.  Yang and Evans~\cite{Yang:2004:DIT:996821.996832, Yang:2006:PMT:1134285.1134325} proposed approaches to discover temporal invariants by analyzing execution traces.  Weimer et al.~\cite{Weimer05miningtemporal,LeGoues:2012:MCQ:2122269.2122550} proposed automated and generic ways to mine temporal specifications based on the assumption that certain parts of the program are more error-prone than others, such as code with poor readability or traces that raise exceptions.  Sekar~\cite{DBLP:conf:ndss:Sekar09} does approximate string comparison to infer input/output relationship between web application requests and responses to help eliminate code injection attacks.  Such inference techniques generally require a large number of execution traces, as well as that the majority of them are correct.  This assumption is not necessarily true in our problem.  

\subsection{OAuth Protocol Analysis}
Bansal et al.~\cite{6266164} modeled OAuth 2.0 protocol and verified it using ProVerif~\cite{Blanchet:2001:ECP:872752.873511}.  They also built a library for future researchers to model web APIs into ProVerif language in a easier fashion.  Pai et al.~\cite{5966531} used Alloy framework~\cite{Alloy} to verify OAuth 2.0 and discovered a previously known vulnerability.  Sun et al.~\cite{Sun:2012:DDE:2382196.2382238} discussed a number of website problems affecting OAuthâ€™s effectiveness, such as not using HTTPS, having cross-site scripting and cross-site request forgery bugs.  The fact that both SSO services we studied are based on OAuth is mainly because of its widespread adoption, but the security issues we found concern the SDK and service implementations, rather than flaws inherent in the OAuth protocol.  

\section{An Illustrative Example}
\label{sec:explicating_illustrative_example}

To motivate our work, we describe a simple example in the context of the Microsoft Live Connect (Microsoft's Single Sign-On service). It illustrates what can go wrong when SDKs are provided without thoroughly specifying their underlying security assumptions.   

\subsection{Intended Use}

To start things from scratch, we assume the developer has no previous experience with such implementation.  The most reasonable first thought is to visit the developer guide\footnote{Information accurate as of April 2014} for Microsoft Live~\cite{LiveConnectDoc}.  This page provides code snippets in JavaScript, C\#, Objective-C and Java showing how to use Live Connect SDK to sign users into a client app.  Ignoring the irrelevant details, we generalize the code snippets to the authentication logic shown in Figure~\ref{fig:live_access_token}.

\begin{figure}[hbt]
\centering
\includegraphics[width=.5\textwidth]{figures/live_access_token}
\caption{Documented Microsoft Live Connect authentication logic}
\label{fig:live_access_token}
\end{figure}

In the figure, WL stands for Windows Live. A developer first needs to call \code{WL.login} defined in the JavaScript SDK. The call takes an argument value ``wl.basic'', indicating that the app will need to read the user's basic information after the function returns an \emph{access\_token} in step (2).  The \emph{access\_token} is the same as described earlier in Chapter~\ref{sec:bg_sso_protocol}.  Once the app obtains the access token, it calls another function, shown in step (3), to get the user's basic information.  The call is essentially equivalent to issuing an HTTP request to the following URL:

\setlength{\fboxrule}{0pt}
\fbox{\parbox[c][4em][c]{\textwidth}{\url{https://apis.live.net/v5.0/me?access_token=ACCESS_TOKEN}} }

The Live ID service responds with the user's name and Microsoft Live ID in the message in step (4). This completes the process, authenticating the user with the provided information. 

\subsection{Unintended (Hazardous) Use}

The developer guide as depicted in Figure~\ref{fig:live_access_token} is valid for a client-only application, but it is not clear that the same logic must not be used with an application that also incorporates an online service.  Without stating this explicitly, developers may be inclined to use the SDK insecurely as shown in Figure~\ref{fig:live_access_token_2}. The interactions with the Live ID service are identical in the two figures.  The only difference is that in the second scenario, the \emph{access\_token} is sent back to the back-end server of the application in step (2a) and it is the app server that makes the REST API call to retrieve user information and authenticate. 

\begin{figure}[hbt]
\centering
\includegraphics[width=.5\textwidth]{figures/live_access_token_2}
\caption{Documented Microsoft Live Connect authentication logic}
\label{fig:live_access_token_2}
\end{figure}

This can lead to a serious vulnerability that allows any application on the device to sign into the app server as the user. A rogue app may send a legitimate request to the Live ID service for an \emph{access\_token} to view public information of the victim, and the user granted the requested information without suspicion.  The problem is this token, obtained by the rogue app and intended for authorizing access to the user's resource, can be abused and sent to the vulnerable application's back-end server from the rogue app developers to perform an impersonation attack.  Since the vulnerable app's server never checks which application the \emph{access\_token} is issued for, it would happily accept the token from rogue app developers and authenticate them as the victim.  A quick search on the app market reveals that this mistake is fairly common in real world applications.  In addition, although we first observed it when analyzing the Live Connect documentation, we later found that many apps using the Facebook SDK suffer from the same issue.  

\subsection{Resolution and Insights}

From one perspective, this is simply a matter of developers writing buggy apps, and the blame for the security vulnerability rests with the app developers.  We argue, though, that the purpose of the SDK is to enable average developers to produce applications that achieve desired security properties by default, and the prevalence of buggy apps created using this SDK indicates a failure of the larger engineering process.  The developer exercised reasonable prudence by using the \emph{access\_token} to query the ID service for user information and followed exactly the process described in the SDK's documentation (Figure~\ref{fig:live_access_token}).  The problem is a lack of deeper understanding of the difference between authentication and authorization, and the role of the \emph{access\_token} (i.e., why it is safe to use the \emph{access\_token} as shown in Figure~\ref{fig:live_access_token} but not in Figure~\ref{fig:live_access_token_2}).  Correct usage depends on subtle understanding of what kind of evidence each message represents and whether or not the whole message sequence establishes an effective proof for a security decision.  It is unrealistic to expect an average developer to understand these subtleties, especially without a clear guidance from the SDK.

We contacted the developers of some of the vulnerable apps. A few apps have been fixed in response to our reports.  We also notified the OAuth Working Group in June 2012 about these vulnerable apps.  Dick Hardt, one of the editors of OAuth 2.0 specification (RFC 6749)~\cite{OAuth2.0}, emailed us requesting a paragraph to be included in the specification to address this issue.  We proposed the initial text and discussed with working group members.  This has resulted in Section 10.16 ``Misuse of Access Token to Impersonate Resource Owner in Implicit Flow'' being added to the specification.

The key point we want to get across in this example is that security of applications constructed with an SDK depends on an understanding of the external service offered by the SDK provider, as well as subtleties in the use of tokens and assumptions about evidence used in authentication and authorization decisions.  We believe the prevalence of vulnerable apps constructed using current SDKs yield compelling evidences that a better engineering process is needed, rather than just passing the blame to overburdened developers.  This motivates us to advocate for a process that explicates SDKs by systematically identifying the underlying assumptions upon which secure usage depends.

\section{The Explication Process}
\label{sec:explicating_explication_process}
\section{Semantic Modeling}
\label{sec:explicating_semantic_modeling}
\section{Discoveries}
\label{sec:explicating_discoveries}
