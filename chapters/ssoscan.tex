\chapter{SSOScan: Automatic Vulnerability Scanner}
\label{sec:ssoscan}

Chapter~\ref{sec:explication} demonstrates that service provider's documentation and SDKs are far from perfect and often missing implicit security-critical assumptions, and an exploratory study in Chapter~\ref{sec:explicating_test} shows that many application developers are prone to miss such assumptions which may cause serious vulnerabilities.  

To better understand and mitigate these risks, we present our design and implementation of SSOScan in this Chapter, an automated vulnerability checker for applications using SSO.  SSOScan carries out simulated attacks automatically by observing the application and monitors the application behavior through this process to determine vulnerability status.  Compared to the manual studies we presented in Chapter~\ref{sec:explicating_test}, SSOScan is capable of successfully checking 80\% of high-profile web applications in a short period of time per test without requiring any human interaction.  

SSOScan prototype focuses on Facebook as the identity provider, but our approach is generic and could be applied to check other identity providers as well.  It takes a website URL as input, determines if that site uses Facebook SSO, and automatically signs into the site using Facebook test accounts and completes the registration process when necessary.  Then, SSOScan simulates several attacks on the site while observing the responses and monitoring network traffic to automatically determine if the application is vulnerable to any of the tested vulnerabilities.  In addition to Single Sign-On services, many of the automation heuristics and techniques could also be adapted to scan for vulnerabilities in integrating other security-critical services such as online payments and file sharing APIs.

For the rest of this Chapter, we first show in Chapter~\ref{sec:ssoscan_manual_example} the human effort involved in manually checking an example application for the assumption IE vulnerability status mentioned in Chapter~\ref{sec:explicating_illustrative_example}.  This gives readers a general idea of what actions SSOScan needs to automate.  Then, we discuss some closely related works in this field in Chapter~\ref{sec:ssoscan_related_work}, and the vulnerabilities SSOScan aims to detect in Chapter~\ref{sec:ssoscan_vuls}.  In Chapter~\ref{sec:ssoscan_design} we explain the design and implementation of SSOScan, and present the large-scale study results we obtained by using SSOScan to check the top 20,000-ranked websites according to Quantcast in Chapter~\ref{sec:ssoscan_study}.  Our exploration experiments and results to improve SSOScan's speed and automation success rate are given in Chapter~\ref{sec:ssoscan_heuristics}.  Finally, we discuss the vendor responses we got and possible deployment scenarios for SSOScan in Chapter~\ref{sec:ssoscan_deployment}.

\section{A manual scanning example}
\label{sec:ssoscan_manual_example}

For reader's convenience, we recap the vulnerability previously mentioned in Chapter~\ref{sec:explicating_illustrative_example}.  The vulnerability exists because the application uses \emph{access\_token} as the only credential to authenticate users through Facebook SSO, and \emph{access\_token} is not tied to a particular application.  Denoting Mallory as the malicious party, Alice as the victim, and Foo as the vulnerable application, this vulnerability can be exploited using the following steps:  (0.0) Alice and Mallory both own accounts at IdP.  (0.1) Mallory lures Alice to use Mallory's rogue application, through which Mallory obtains Alice's \emph{access\_token} for the rogue application as a preparation stage for the attack.  (0.2) We assume Alice uses Foo application previous to the attack.  (1) Mallory performs necessary actions to log in to Foo using Mallory's own IdP account.  (2) As the IdP returns the \emph{access\_token} to Mallory's browser, Mallory swaps it with the previously obtained \emph{access\_token} from Alice.  (3) 
Mallory checks with the browser to see if Foo has indeed authenticated Mallory as Alice, i.e. if Foo is vulnerable to this impersonation attack.

Playing as both the victim and the perpetrator, these steps are essentially what we did to test the 27 applications in Chapter~\ref{sec:explicating_test}, and here we list the actual actions performed to test the example \url{http://www.espn.go.com} web application.  

\begin{itemize}

\item \textbf{Test account registration.}  In step (0.0), we register two test accounts at Facebook for both Alice and Mallory.

\item \textbf{\emph{Access\_token} stealing.}  In step (0.1), we obtain Alice's \emph{access\_token} for Mallory's application by visiting a crafted URL and getting the token in the Facebook response.

\begin{figure}[hbt]
\centering
\includegraphics[width=.7\textwidth]{figures/chapter4/ssoscan_espn_login_button}
\caption{ESPN login buttons on homepage}
\label{fig:ssoscan_espn_login_button}
\end{figure}

\item \textbf{Clicking ``login through SSO'' button(s).}  In step (0.2) and (1), we need to click the correct button(s) to initiate the SSO process.  For ESPN.com, this is to click the `sign in' button in the upper-right corner, and then the `login with Facebook' button in the pop-up layer , as shown in Figure~\ref{fig:ssoscan_espn_login_button}.

\begin{figure}[bht]
\centering
\includegraphics[width=.5\textwidth]{figures/chapter4/ssoscan_espn_facebook_login}
\caption{Typical Facebook login form}
\label{fig:ssoscan_espn_facebook_login}
\end{figure}

\item \textbf{Automatically fill in Facebook Credentials.}  In step (0.2) and (1), after the SSO process is triggered, we need to input test account information and log in to Facebook.  This process does not vary much for every application, and a typical Facebook login form is shown in Figure~\ref{fig:ssoscan_espn_facebook_login}.

\begin{figure}[hbt]
\centering
\includegraphics[width=.5\textwidth]{figures/chapter4/ssoscan_espn_register}
\caption{ESPN register form after SSO process}
\label{fig:ssoscan_espn_register}
\end{figure}

\item \textbf{Fill in registration forms if necessary.}  In step (0.2) and (1), after the SSO process has completed, we need to fill in additional registration forms if the application so asks.  Certain user information may have already been pre-populated from the test account Facebook profile, as is shown here in Figure~\ref{fig:ssoscan_espn_register}.  For ESPN.com, we simply need to click `finish' button to complete the registration process.

\begin{figure}[bht]
\centering
\includegraphics[width=.8\textwidth]{figures/chapter4/ssoscan_espn_fiddler}
\caption{Using Fiddler proxy to tamper \emph{access\_token}}
\label{fig:ssoscan_espn_fiddler}
\end{figure}

\item \textbf{Manipulate traffic.} In step (2), after IdP returns the token, we need to replace it with another token.  This is done by manually identifying the response token in Fiddler proxy and overwrite it.  We show an example response in Figure~\ref{fig:ssoscan_espn_fiddler} with the string of interest highlighted.

\begin{figure}[hbt]
\centering
\includegraphics[width=\textwidth]{figures/chapter4/ssoscan_espn_oracle}
\caption{Test account first name displayed after SSO process}
\label{fig:ssoscan_espn_oracle}
\end{figure}

\item \textbf{Detect session identity.}  In the final step (3), after the token swap, we need to determine if the attack is successful.  Identifying the currently logged-in user is relatively easy for a human, for example, the upper-right corner of the web page (Figure~\ref{fig:ssoscan_espn_oracle}) shows the user name of current session, which acts as a good indicator.

\end{itemize}

For all the above steps, the first two is necessary to only perform once for all tests;  However, all the rest of the steps are required per test and their actions vary across target applications.  SSOScan attempts to automate these steps in a timely fashion, thus enabling large-scale scanning of vulnerabilities in high-profile websites.  

\section{Related Work}
\label{sec:ssoscan_related_work}

Our work builds on extensive previous work on automatically testing applications for vulnerabilities.  We briefly describe relevant approaches next, as well as previous works that analyze vulnerabilities in SSO services.

\shortsection{Program analysis} Program analysis techniques such as static analysis~\cite{Ball:2002:SLP:503272.503274} and dynamic analysis including symbolic execution~\cite{Cadar:2005:EGT:2156342.2156345,Kudzu} automatically identify vulnerabilities with fast testing speed and good code coverage.  Runtime instrumentation techniques such as taint tracking~\cite{Nentwich07cross-sitescripting} and inference~\cite{DBLP:conf:ndss:Sekar09} also help to safeguard sensitive source-sink pairs.  However, these techniques require white-box access to the application (at least at the level of its binary), which is not available for remote web application testing.  Automated web application testing tools that work on the server implementation~\cite{1167787,Ricca:2001:ATW:381473.381476,Alshahwan:2011:AWA:2190078.2190141} do not apply to large-scale vulnerability testing well.  They either require access to application source code or other specific details such as UML or application states.  For our purposes, the test target (application server implementation) is only available as a black box.

\shortsection{Oracle-based security testing} Penetration testing is widely used to check applications for vulnerabilities~\cite{whitehat,redspin}.  The tester analyzes the system and performs simulated attacks on it, often requiring substantial manual effort.  More automated testing requires an oracle to determine whether or not a test failed.  Sprenkle et al.\ developed a difference metric by comparing two webpages based on DOM structure and n-grams~\cite{Sprenkle:2005:ARF:1101908.1101947} and improved results using machine learning techniques~\cite{Sprenkle07learningeffective}.  SSOScan also requires an oracle (Chapter~\ref{sec:ssoscan_design_oracle}) to determine session identity. For our purposes, a targeted oracle works better than their generic approach.

\shortsection{Automated GUI testing} SSOScan is also closely related to automated GUI testing.  The GUI element triggering approach we take shares some similarities with recent works to simulate random user interactions on GUI element to explore application execution space on Android system~\cite{Rastogi:2013:AAS:2435349.2435379}, native Windows applications~\cite{Xie:2006:MTC:1172962.1172990}, and web applications~\cite{Benedikt02veriweb:automatically,Huang:2003:WAS:775152.775174}.  Their common goal is to explore app execution space efficiently to discover buggy, abnormal or malicious behavior.  By contrast, our goal is to drive the application through a particular SSO process rather than explore its execution space.  Further, we need the tests to proceed fast enough for large-scale evaluation.  Since each simulated user interaction with the web application involves round-trip traffic and a non-trivial delay to get the response, our primary focus is to develop useful heuristics to quickly prune search space before triggering any user interactions.

SmartDroid~\cite{Zheng:2012:SAS:2381934.2381950} and AppIntent~\cite{Yang:2013:AAS:2541806.2516676} both aim to recover sequences of UI events required to reach a particular program state or follow an execution path obtained from static analysis.  These approaches target Android applications and rely on client-side information that is not available for our web application scanning tool, where the necessary state only exists on the (inaccessible) server side.

\shortsection{Human cooperative testing} Off-the-shelf testing tools like Selenium~\cite{Selenium} and TestingBot~\cite{TestingBot} can be used to discover bugs in web applications under developers' assistance.  These tools replay user interactions based on testing scripts that are manually created by the application developer.  BugBuster~\cite{BugBuster} offers some automatic web application exploration capabilities, but still does not understand the application context enough to perform any non-trivial actions such as those involving authentication and business logic.

To reduce developer effort, Pirolli et al.~\cite{Pirolli:2002:UAM:1556262.1556272}, Elbaum et al.~\cite{Elbaum:2003:IWA:776816.776823}, and the Zaddach tool~\cite{zaddach:ndss14} show promising results by collecting interactions from normal users and replaying them to learn application states and invariants for vulnerability scanning.  These works do not require extra manual effort from developers to write testing script or specify user interactions.  However, one potential problem these works fail to address is user's privacy concerns when submitting every interaction.  This could be especially sensitive when the actions involve passwords or payments.  SSOScan avoids this problem and is complementary to this line of work --- in most cases, SSOScan attempts to scan applications in a fully automatic fashion and does not require traces from any party.  When SSOScan fails, traces submitted from the users may guide SSOScan to complete the scan.

\shortsection{SSO security} We have already covered some works on SSO-related security analysis in Chapter~\ref{sec:explicating_prior_works}, however, we want to point out two additional closely related works in SSO application scanning.

Integuard~\cite{Integuard} and AuthScan~\cite{AuthScan} have similar goals with SSOScan.  Integuard infers invariants across requests and responses and uses them to perform intrusion detection on future activities.  AuthScan~\cite{AuthScan} is an automated tool to extract specifications from SSO implementations by using both static program analysis and dynamic behavior probing.  Our goals differ in that we focus on detecting specific vulnerabilities rather than generic ones.  This enables us to establish clear automation goals and build well-defined state machines for the scanner, and removes the uncertainties the previous works incur when inferring invariants or modeling unknown functions.  The drawback is our approach relies on knowledge of particular vulnerabilities.  For many integrated web services, including SSO, many vulnerabilities are known or can be obtained using systematic explication as described in Chapter~\ref{sec:explication}.

\section{Targeted Vulnerabilities}
\label{sec:ssoscan_vuls}

In addition to the \emph{access\_token} vulnerability discussed in Chapter~\ref{sec:ssoscan_manual_example}, SSOScan aims to scan for three other vulnerabilities.  The four vulnerabilities can be categorized into two general types.

\shortsection{Credential Misuse}  If an application uses \emph{access\_token} to authenticate users, we classify the application as misusing credentials.  However, sometimes even the developers chose the correct OAuth credentials to use, their application still ends up with a vulnerable implementation.  One way this happens is when information decoded from a \emph{signed\_request} is used but the signature is never checked using the \emph{app\_secret}.  The attack to exploit this vulnerability is similar to the \emph{access\_token} simulated attack, except that Mallory needs to replace the \emph{signed\_request} in addition to \emph{access\_token}.

\begin{figure}[hbt]
\centering
\includegraphics[width=\textwidth]{figures/chapter4/ssoscan_vuls_leakage}
\caption{OAuth \emph{Code} leaked through the Referer header}
\label{fig:ssoscan_vuls_leakage}
\end{figure}

\shortsection{Credential Leakage}  The OAuth credentials can be accidentally leaked to a potentially malicious third-party, if the application developer does not pay attention.  When the Facebook OAuth landing page contains third-party content, requests to retrieve those contents will automatically include OAuth credentials in the \code{Referer} header, which leaks them to the third-party.  In addition, credentials can be exfiltrated by third-party scripts if they are present in the page content.  If a malicious party is able to obtain these credentials, it could carry out impersonation attacks or perform malicious actions using permissions the user granted the original application, such as posting on user's timeline or accessing sensitive information.

\section{Design and Implementation}
\label{sec:ssoscan_design}

\begin{figure}[hbt]
\centering
\includegraphics[width=\textwidth]{figures/chapter4/ssoscan_overview}
\caption{SSOScan components overview}
\label{fig:ssoscan_overview}
\end{figure}

SSOScan consists of two main parts: the Enroller and the Vulnerability Tester, as shown in Figure~\ref{fig:ssoscan_overview}.  Ovals represent testing states, curved rectangles represent different modules in our tool, and diamonds represent control flow decisions.  

Left of Figure~\ref{fig:ssoscan_overview} describes the workflow of the Enroller.  The Enroller automatically registers two test accounts at target web application using Facebook SSO login.  Given a target web application \emph{A}, our tool first removes all cookies from the browser and navigate to \emph{A}.  A short delay after the page has fired its \code{onload} event, the SSO button finder (Section~\ref{sec:ssoscan_design_bf}) analyzes the DOM and outputs the most likely candidate elements for SSO button.  The Enroller then simulates clicks on those elements, monitoring traffic to listen for the Facebook SSO traffic pattern.

When traffic to Facebook SSO entry point is captured, SSOScan automatically logs into Facebook and grants the requested permissions to the application.  OAuth credentials returned from Facebook are stored for future use.  An important and challenging step after the SSO process is to automatically complete the registration form when applicable.  SSOScan combines heuristics with random inputs to fill in forms (Section~\ref{sec:ssoscan_design_cr}) and locate and click the submit button.  Should this process fail, the Enroller would try again using a different option (Section~\ref{sec:ssoscan_heuristics_options}) and repeats the process until success or giving up after trying all available options.  

After successfully enrolling both test accounts at target application, the Vulnerability Tester (Chapter~\ref{sec:ssoscan_design_vt}) performs simulated attacks on the application and monitors the traffic and its behavior to determine vulnerability status.  An identity oracle (Chapter~\ref{sec:ssoscan_design_oracle}) is necessary for both the Enroller and the Vulnerability Tester due to different purposes.

\subsection{SSO Button Finder}
\label{sec:ssoscan_design_bf}

Using Figure~\ref{fig:ssoscan_espn_login_button} as an example, the SSO button finder needs to locate the upper-right corner for `sign in' and then the `login with Facebook' button in the middle of the page.  To automate this, SSOScan first extracts a list of qualifying elements from all nodes in an HTML page, and then extracts content strings from such elements.  The Button Finder relies on the assumption that developers put one of a small pre-defined set of expected strings in the text content or attributes of the SSO button, and our evaluation results (Section~\ref{sec:ssoscan_study}) confirm that this assumption is nearly always valid.  SSOScan computes a score for each element by matching its content with regular expressions such as \code{[Ll][Oo][Gg][IiOo][Nn]} which indicates its resemblance to ``login''.  SSOScan forms a candidate pool consisting of the top-scoring elements and triggers clicks on them.  This process can be illustrated using Figure~\ref{fig:ssoscan_design_button_finder}.  We defer the details such as the heuristic choices SSOScan uses to filter elements and compute scores to Section~\ref{sec:ssoscan_heuristics}.

\begin{figure}[hbt]
\centering
\includegraphics[width=0.7\textwidth]{figures/chapter4/ssoscan_design_button_finder}
\caption{SSO Button Finder workflow}
\label{fig:ssoscan_design_button_finder}
\end{figure}

Once the login button has been found and the traffic to Facebook's OAuth endpoint has been captured, automating logging into Facebook is straightforward.  Upon detection of Facebook login DOM structure, we automatically fill in the username/password field using test account information.  SSOScan also grants all requested permissions to the application to facilitate registration.

\subsection{Completing Registration}
\label{sec:ssoscan_design_cr}

The required interactions to complete the registration process after single sign-on vary significantly across web applications.  They range from simply clicking a submit button (e.g., Figure~\ref{fig:ssoscan_espn_register}, in which all input fields are pre-populated using information taken from the SSO process), to very complicated registration processes that involve interactively filling in multiple forms and possibly CAPTCHA solving.

SSOScan attempts to complete all forms on the SSO landing page by leaving pre-populated fields untouched and processing the remaining inputs in the order of radios, selects, checkboxes and finally text inputs.  We found this ordering to be very important to achieve higher automation success, as some forms may dynamically change what needs to be filled upon selecting different radio or select elements.  Processing these elements first allows SSOScan to rescan for dynamically generated fields and process them accordingly.  

For radio and select elements, SSOScan randomly chooses an option; for checkboxes, it simply checks all of them.  For text inputs, SSOScan tries to infer their requirements using heuristics and provide satisfactory mock values.  Once all the inputs have been filled, the next step is to reuse the SSO Button Finder with different regular expressions and settings specifically designed to find submit buttons.  After SSOScan attempts to click on a submit button candidate, it refers to the oracle~\ref{sec:ssoscan_design_oracle} to determine if the entire registration process is successful.

\subsection{Oracle}
\label{sec:ssoscan_design_oracle}

The Oracle analyzes the application and determines whether it is in an authenticated state, and if so, further identifies the session identity.  This module is necessary for SSOScan to decide if a registration attempt is successful.  It is also used by the Vulnerability Tester to determine if a simulated impersonation attack succeeds.

The key observation behind the Oracle is that web applications normally remove the original login button and display some identifying information about the user in an authenticated session.  For example, after a successful registration many websites display a welcome message that includes the user's first name (Figure~\ref{fig:ssoscan_espn_oracle}).  Therefore, the Oracle works by searching the entire DOM and \code{document.cookie} for test account user information (e.g., names, email, or profile images) after the page has finished loading.

\subsection{Vulnerability Tester}
\label{sec:ssoscan_design_vt}

After the Enroller successfully registers two test accounts, control is passed to the Vulnerability Tester which checks the target application for the vulnerabilities described in Section~\ref{sec:ssoscan_vuls}.  We use two different probing approaches to cover the five tested vulnerabilities: \emph{simulated attacks} and \emph{passive monitoring}.

\shortsection{Simulated Attacks} The two credential misuse vulnerabilities are tested using simulated impersonation attacks.  We have already outlined the steps to manually carry out such attacks in Chapter~\ref{sec:ssoscan_manual_example}.  To automate it, SSOScan simply invokes existing components to complete logins.  The only difference is that SSOScan will replace the OAuth credentials in Facebook's response with those previously obtained from Alice.

The attack is successful if Bob is able to login as Alice using the replaced credential.  The Vulnerability Tester deems the site vulnerable if the Oracle determines that Alice is the logged in user after the simulated attack.

\shortsection{Passive Monitoring}  The credential leakage vulnerabilities are detected using passive approaches.  For brevity, we only explain how leaks through the \code{Referer} header are detected; the other leaks are detected similarly by observing network traffic and web page contents.

To check if an application leaks the user's OAuth credentials through the \code{Referer} header, SSOScan monitors all request data during the account registration process and compares each \code{Referer} header to OAuth credentials recorded in earlier stages.  If a match is found, SSOScan then checks if the requesting page contains any third-party content such as scripts, images, or other elements that may generate an HTTP request.  SSOScan reports a potential leakage when credentials are found in the \code{Referer} header for a page that also contains third-party content.

\section{Large-scale Study}
\label{sec:ssoscan_study}
\section{Heuristics Evaluation}
\label{sec:ssoscan_heuristics}
\subsection{SSOScan Options}
\label{sec:ssoscan_heuristics_options}

\section{Vendor Response and Deployment}
\label{sec:ssoscan_deployment}