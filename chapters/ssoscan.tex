\chapter{SSOScan: Automatic Vulnerability Scanner}
\label{sec:ssoscan}

Chapter~\ref{sec:explication} demonstrates that service provider's documentation and SDKs are far from perfect and often missing implicit security-critical assumptions, and an exploratory study in Chapter~\ref{sec:explicating_test} shows that many application developers are prone to miss such assumptions which may cause serious vulnerabilities.  

To better understand and mitigate these risks, we present our design and implementation of SSOScan in this Chapter, an automated vulnerability checker for applications using SSO.  SSOScan carries out simulated attacks automatically by observing the application and monitors the application behavior through this process to determine vulnerability status.  Compared to the manual studies we presented in Chapter~\ref{sec:explicating_test}, SSOScan is capable of successfully checking 80\% of high-profile web applications in a short period of time per test without requiring any human interaction.  

SSOScan prototype focuses on Facebook as the identity provider, but our approach is generic and could be applied to check other identity providers as well.  It takes a website URL as input, determines if that site uses Facebook SSO, and automatically signs into the site using Facebook test accounts and completes the registration process when necessary.  Then, SSOScan simulates several attacks on the site while observing the responses and monitoring network traffic to automatically determine if the application is vulnerable to any of the tested vulnerabilities.  In addition to Single Sign-On services, many of the automation heuristics and techniques could also be adapted to scan for vulnerabilities in integrating other security-critical services such as online payments and file sharing APIs.

For the rest of this Chapter, we first show in Chapter~\ref{sec:ssoscan_manual_example} the human effort involved in manually checking an example application for the assumption IE vulnerability status mentioned in Chapter~\ref{sec:explicating_illustrative_example}.  This gives readers a general idea of what actions SSOScan needs to automate.  Then, we discuss some closely related works in this field in Chapter~\ref{sec:ssoscan_related_work}.  In Chapter~\ref{sec:ssoscan_design} we explain the design and implementation of SSOScan, and present the large-scale study results we obtained by using SSOScan to check the top 20,000-ranked websites according to Quantcast in Chapter~\ref{sec:ssoscan_study}.  Our exploration experiments and results to improve SSOScan's speed and automation success rate are given in Chapter~\ref{sec:ssoscan_heuristics}.  Finally, we discuss the vendor responses we got and possible deployment scenarios for SSOScan in Chapter~\ref{sec:ssoscan_deployment}.

\section{A manual scanning example}
\label{sec:ssoscan_manual_example}

For reader's convenience, we recap the vulnerability previously mentioned in Chapter~\ref{sec:explicating_illustrative_example}.  The vulnerability exists because the application uses \emph{access\_token} as the only credential to authenticate users through Facebook SSO, and \emph{access\_token} is not tied to a particular application.  Denoting Mallory as the malicious party, Alice as the victim, and Foo as the vulnerable application, this vulnerability can be exploited using the following steps:  (0.0) Alice and Mallory both own accounts at IdP.  (0.1) Mallory lures Alice to use Mallory's rogue application, through which Mallory obtains Alice's \emph{access\_token} for the rogue application as a preparation stage for the attack.  (0.2) We assume Alice uses Foo application previous to the attack.  (1) Mallory performs necessary actions to log in to Foo using Mallory's own IdP account.  (2) As the IdP returns the \emph{access\_token} to Mallory's browser, Mallory swaps it with the previously obtained \emph{access\_token} from Alice.  (3) 
Mallory checks with the browser to see if Foo has indeed authenticated Mallory as Alice, i.e. if Foo is vulnerable to this impersonation attack.

Playing as both the victim and the perpetrator, these steps are essentially what we did to test the 27 applications in Chapter~\ref{sec:explicating_test}, and here we list the actual actions performed to test the example \url{http://www.espn.go.com} web application.  

\begin{itemize}

\item \textbf{Test account registration.}  In step (0.0), we register two test accounts at Facebook for both Alice and Mallory.

\item \textbf{\emph{Access\_token} stealing.}  In step (0.1), we obtain Alice's \emph{access\_token} for Mallory's application by visiting a crafted URL and getting the token in the Facebook response.

\begin{figure}[hbt]
\centering
\includegraphics[width=.7\textwidth]{figures/chapter4/ssoscan_espn_login_button}
\caption{ESPN login buttons on homepage}
\label{fig:ssoscan_espn_login_button}
\end{figure}

\item \textbf{Clicking ``login through SSO'' button(s).}  In step (0.2) and (1), we need to click the correct button(s) to initiate the SSO process.  For ESPN.com, this is to click the `sign in' button in the upper-right corner, and then the `login with Facebook' button in the pop-up layer , as shown in Figure~\ref{fig:ssoscan_espn_login_button}.

\begin{figure}[bht]
\centering
\includegraphics[width=.5\textwidth]{figures/chapter4/ssoscan_espn_facebook_login}
\caption{Typical Facebook login form}
\label{fig:ssoscan_espn_facebook_login}
\end{figure}

\item \textbf{Automatically fill in Facebook Credentials.}  In step (0.2) and (1), after the SSO process is triggered, we need to input test account information and log in to Facebook.  This process does not vary much for every application, and a typical Facebook login form is shown in Figure~\ref{fig:ssoscan_espn_facebook_login}.

\begin{figure}[hbt]
\centering
\includegraphics[width=.5\textwidth]{figures/chapter4/ssoscan_espn_register}
\caption{ESPN register form after SSO process}
\label{fig:ssoscan_espn_register}
\end{figure}

\item \textbf{Fill in registration forms if necessary.}  In step (0.2) and (1), after the SSO process has completed, we need to fill in additional registration forms if the application so asks.  Certain user information may have already been pre-populated from the test account Facebook profile, as is shown here in Figure~\ref{fig:ssoscan_espn_register}.  For ESPN.com, we simply need to click `finish' button to complete the registration process.

\begin{figure}[bht]
\centering
\includegraphics[width=.8\textwidth]{figures/chapter4/ssoscan_espn_fiddler}
\caption{Using Fiddler proxy to tamper \emph{access\_token}}
\label{fig:ssoscan_espn_fiddler}
\end{figure}

\item \textbf{Manipulate traffic.} In step (2), after IdP returns the token, we need to replace it with another token.  This is done by manually identifying the response token in Fiddler proxy and overwrite it.  We show an example response in Figure~\ref{fig:ssoscan_espn_fiddler} with the string of interest highlighted.

\begin{figure}[hbt]
\centering
\includegraphics[width=\textwidth]{figures/chapter4/ssoscan_espn_oracle}
\caption{Test account first name displayed after SSO process}
\label{fig:ssoscan_espn_oracle}
\end{figure}

\item \textbf{Detect session identity.}  In the final step (3), after the token swap, we need to determine if the attack is successful.  Identifying the currently logged-in user is relatively easy for a human, for example, the upper-right corner of the web page (Figure~\ref{fig:ssoscan_espn_oracle}) shows the user name of current session, which acts as a good indicator.

\end{itemize}

For all the above steps, the first two is necessary to only perform once for all tests;  However, all the rest of the steps are required per test and their actions vary across target applications.  SSOScan attempts to automate these steps in a timely fashion, thus enabling large-scale scanning of vulnerabilities in high-profile websites.  

\section{Related Work}
\label{sec:ssoscan_related_work}

Our work builds on extensive previous work on automatically testing applications for vulnerabilities.  We briefly describe relevant approaches next, as well as previous works that analyze vulnerabilities in SSO services.

\shortsection{Program analysis} Program analysis techniques such as static analysis~\cite{Ball:2002:SLP:503272.503274} and dynamic analysis including symbolic execution~\cite{Cadar:2005:EGT:2156342.2156345,Kudzu} automatically identify vulnerabilities with fast testing speed and good code coverage.  Runtime instrumentation techniques such as taint tracking~\cite{Nentwich07cross-sitescripting} and inference~\cite{DBLP:conf:ndss:Sekar09} also help to safeguard sensitive source-sink pairs.  However, these techniques require white-box access to the application (at least at the level of its binary), which is not available for remote web application testing.  Automated web application testing tools that work on the server implementation~\cite{1167787,Ricca:2001:ATW:381473.381476,Alshahwan:2011:AWA:2190078.2190141} do not apply to large-scale vulnerability testing well.  They either require access to application source code or other specific details such as UML or application states.  For our purposes, the test target (application server implementation) is only available as a black box.

\shortsection{Oracle-based security testing} Penetration testing is widely used to check applications for vulnerabilities~\cite{whitehat,redspin}.  The tester analyzes the system and performs simulated attacks on it, often requiring substantial manual effort.  More automated testing requires an oracle to determine whether or not a test failed.  Sprenkle et al.\ developed a difference metric by comparing two webpages based on DOM structure and n-grams~\cite{Sprenkle:2005:ARF:1101908.1101947} and improved results using machine learning techniques~\cite{Sprenkle07learningeffective}.  SSOScan also requires an oracle (Chapter~\ref{sec:ssoscan_design_oracle}) to determine session identity. For our purposes, a targeted oracle works better than their generic approach.

\shortsection{Automated GUI testing} SSOScan is also closely related to automated GUI testing.  The GUI element triggering approach we take shares some similarities with recent works to simulate random user interactions on GUI element to explore application execution space on Android system~\cite{Rastogi:2013:AAS:2435349.2435379}, native Windows applications~\cite{Xie:2006:MTC:1172962.1172990}, and web applications~\cite{Benedikt02veriweb:automatically,Huang:2003:WAS:775152.775174}.  Their common goal is to explore app execution space efficiently to discover buggy, abnormal or malicious behavior.  By contrast, our goal is to drive the application through a particular SSO process rather than explore its execution space.  Further, we need the tests to proceed fast enough for large-scale evaluation.  Since each simulated user interaction with the web application involves round-trip traffic and a non-trivial delay to get the response, our primary focus is to develop useful heuristics to quickly prune search space before triggering any user interactions.

SmartDroid~\cite{Zheng:2012:SAS:2381934.2381950} and AppIntent~\cite{Yang:2013:AAS:2541806.2516676} both aim to recover sequences of UI events required to reach a particular program state or follow an execution path obtained from static analysis.  These approaches target Android applications and rely on client-side information that is not available for our web application scanning tool, where the necessary state only exists on the (inaccessible) server side.

\shortsection{Human cooperative testing} Off-the-shelf testing tools like Selenium~\cite{Selenium} and TestingBot~\cite{TestingBot} can be used to discover bugs in web applications under developers' assistance.  These tools replay user interactions based on testing scripts that are manually created by the application developer.  BugBuster~\cite{BugBuster} offers some automatic web application exploration capabilities, but still does not understand the application context enough to perform any non-trivial actions such as those involving authentication and business logic.

To reduce developer effort, Pirolli et al.~\cite{Pirolli:2002:UAM:1556262.1556272}, Elbaum et al.~\cite{Elbaum:2003:IWA:776816.776823}, and the Zaddach tool~\cite{zaddach:ndss14} show promising results by collecting interactions from normal users and replaying them to learn application states and invariants for vulnerability scanning.  These works do not require extra manual effort from developers to write testing script or specify user interactions.  However, one potential problem these works fail to address is user's privacy concerns when submitting every interaction.  This could be especially sensitive when the actions involve passwords or payments.  SSOScan avoids this problem and is complementary to this line of work --- in most cases, SSOScan attempts to scan applications in a fully automatic fashion and does not require traces from any party.  When SSOScan fails, traces submitted from the users may guide SSOScan to complete the scan.

\shortsection{SSO security} We have already covered some works on SSO-related security analysis in Chapter~\ref{sec:explicating_prior_works}, however, we want to point out two additional closely related works in SSO application scanning.

Integuard~\cite{Integuard} and AuthScan~\cite{AuthScan} have similar goals with SSOScan.  Integuard infers invariants across requests and responses and uses them to perform intrusion detection on future activities.  AuthScan~\cite{AuthScan} is an automated tool to extract specifications from SSO implementations by using both static program analysis and dynamic behavior probing.  Our goals differ in that we focus on detecting specific vulnerabilities rather than generic ones.  This enables us to establish clear automation goals and build well-defined state machines for the scanner, and removes the uncertainties the previous works incur when inferring invariants or modeling unknown functions.  The drawback is our approach relies on knowledge of particular vulnerabilities.  For many integrated web services, including SSO, many vulnerabilities are known or can be obtained using systematic explication as described in Chapter~\ref{sec:explication}.

\section{Design and Implementation}
\label{sec:ssoscan_design}
\subsection{Oracle}
\label{sec:ssoscan_design_oracle}
\section{Large-scale Study}
\label{sec:ssoscan_study}
\section{Heuristics Evaluation}
\label{sec:ssoscan_heuristics}
\section{Vendor Response and Deployment}
\label{sec:ssoscan_deployment}